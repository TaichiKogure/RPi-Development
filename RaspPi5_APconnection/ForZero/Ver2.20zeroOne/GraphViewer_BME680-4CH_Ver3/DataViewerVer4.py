#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DataViewer Ver4 - Browser-based Environmental Data Viewer (Python/Flask + Plotly)

Changes from Ver3:
- Unified naming to Ver4.
- Dark, modern UI styling while keeping existing line colors.
- Removed auto-refresh; manual Reload button only.
- Arbitrary display period: numeric days input (any positive integer).
- Min/Max summary table for each parameter over the displayed range.

Data source:
- Fixed CSV files generated by P1 system, per device (P1..P4, no CO2):
  /var/lib(FromThonny)/raspap_solo/data/RawData_P1/P1_fixed.csv
  /var/lib(FromThonny)/raspap_solo/data/RawData_P2/P2_fixed.csv
  /var/lib(FromThonny)/raspap_solo/data/RawData_P3/P3_fixed.csv
  /var/lib(FromThonny)/raspap_solo/data/RawData_P4/P4_fixed.csv

API:
- GET /api/graphs?days=1&show_p1=true&show_p2=true&show_p3=true&show_p4=true
  Returns time-series for temperature, humidity, absolute_humidity, pressure, gas_resistance,
  plus discomfort_index, pollution_index1, pollution_index2, pollution_index3 (if computable).

- GET /download/series?device=P2&param=discomfort_index&days=7
  Returns a CSV with columns [timestamp, param] for the selected device and parameter.

- GET /download/p1 .. /download/p4
  Returns the fixed CSV file as-is for each device.

Dependencies:
- Flask, pandas, plotly
  pip install flask pandas plotly
"""

import os
import math
import argparse
import logging
import datetime
from typing import Optional, Dict, Any

import pandas as pd
from flask import Flask, jsonify, render_template_string, request, send_from_directory, Response

# --------------------------------------------------------------------------------------
# Configuration & Logging
# --------------------------------------------------------------------------------------

DEFAULT_P1_PATH = "/var/lib(FromThonny)/raspap_solo/data/RawData_P1/P1_fixed.csv"
DEFAULT_P2_PATH = "/var/lib(FromThonny)/raspap_solo/data/RawData_P2/P2_fixed.csv"
DEFAULT_P3_PATH = "/var/lib(FromThonny)/raspap_solo/data/RawData_P3/P3_fixed.csv"
DEFAULT_P4_PATH = "/var/lib(FromThonny)/raspap_solo/data/RawData_P4/P4_fixed.csv"
DEFAULT_PORT = 8081
DEFAULT_DAYS = 1

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
    ]
)
logger = logging.getLogger("DataViewerVer4")

# --------------------------------------------------------------------------------------
# HTML Template (client renders Plotly graphs using /api/graphs)
# --------------------------------------------------------------------------------------

INDEX_HTML = """
<!DOCTYPE html>
<html lang=\"en\">
<head>
  <meta charset=\"UTF-8\" />
  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />
  <title>DataViewer Ver4</title>
  <script src=\"https://cdn.plot.ly/plotly-2.27.0.min.js\"></script>
  <script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #151922;
      --text: #e6e6e6;
      --muted: #9aa4b2;
      --border: #262c36;
      --accent: #3ea6ff;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,\n               \"Apple Color Emoji\", \"Segoe UI Emoji\";
    }
    html, body { background: var(--bg); color: var(--text); font-family: var(--font); }
    body { margin: 16px; }
    h1 { margin: 0 0 12px; font-weight: 600; letter-spacing: .2px; }
    .controls { margin: 12px 0 16px; display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
    .controls label { color: var(--muted); }
    .controls input[type=number], .controls select { background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 6px 8px; }
    .controls button { background: var(--accent); color: #0b0b0b; border: none; padding: 8px 14px; border-radius: 8px; font-weight: 600; cursor: pointer; }
    .controls button:hover { filter: brightness(1.05); }

    .downloads { margin: 10px 0; font-size: 14px; color: var(--muted); }
    .downloads a { margin-right: 10px; color: var(--accent); text-decoration: none; }
    .downloads a:hover { text-decoration: underline; }

    .graphs { display: grid; grid-template-columns: repeat(auto-fit, minmax(420px, 1fr)); gap: 14px; }
    .graph { border: 1px solid var(--border); border-radius: 10px; padding: 6px; background: var(--panel); }

    .stats { margin-top: 18px; background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 12px; }
    .stats h2 { margin: 0 0 8px; font-size: 18px; color: var(--muted); }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid var(--border); padding: 6px 8px; text-align: left; }
    th { background: #1b2130; color: var(--text); }
    td { color: var(--text); }
    caption { caption-side: bottom; color: var(--muted); padding-top: 6px; font-size: 12px; }
  </style>
</head>
<body>
  <h1>DataViewer Ver4</h1>
  <div class=\"controls\">
    <label>Display range (days):
      <input id=\"days\" type=\"number\" min=\"1\" step=\"1\" value=\"1\" />
    </label>
    <label><input type=\"checkbox\" id=\"p1\" checked /> P1</label>
    <label><input type=\"checkbox\" id=\"p2\" checked /> P2</label>
    <label><input type=\"checkbox\" id=\"p3\" checked /> P3</label>
    <label><input type=\"checkbox\" id=\"p4\" checked /> P4</label>
    <button id=\"reload\">Reload</button>
  </div>

  <div class=\"downloads\">
    <strong>CSV downloads (respecting range and devices):</strong>
    <span id=\"download-links\"></span>
  </div>

  <div class=\"downloads\"> 
    <strong>Fixed CSV downloads (all data):</strong>
    <a href=\"/download/p1\" download>P1 Full Data</a>
    <a href=\"/download/p2\" download>P2 Full Data</a>
    <a href=\"/download/p3\" download>P3 Full Data</a>
    <a href=\"/download/p4\" download>P4 Full Data</a>
  </div>

  <div class=\"graphs\">
    <div class=\"graph\"><div id=\"temperature\"></div></div>
    <div class=\"graph\"><div id=\"humidity\"></div></div>
    <div class=\"graph\"><div id=\"absolute_humidity\"></div></div>
    <div class=\"graph\"><div id=\"pressure\"></div></div>
    <div class=\"graph\"><div id=\"gas_resistance\"></div></div>
    <div class=\"graph\"><div id=\"discomfort_index\"></div></div>
    <div class=\"graph\"><div id=\"pollution_index1\"></div></div>
    <div class=\"graph\"><div id=\"pollution_index2\"></div></div>
    <div class=\"graph\"><div id=\"pollution_index3\"></div></div>
  </div>

  <div class=\"stats\">
    <h2>Min/Max for each parameter in selected range</h2>
    <div id=\"stats-table-container\"></div>
  </div>

  <script>
    const paramMeta = [
      { id: 'temperature', label: 'Temperature (°C)' },
      { id: 'humidity', label: 'Relative Humidity (%)' },
      { id: 'absolute_humidity', label: 'Absolute Humidity (g/m³)' },
      { id: 'pressure', label: 'Pressure (hPa)' },
      { id: 'gas_resistance', label: 'Gas Resistance (Ω)' },
      { id: 'discomfort_index', label: 'Discomfort Index' },
      { id: 'pollution_index1', label: 'Pollution Index 1 (1e6/GR)' },
      { id: 'pollution_index2', label: 'Pollution Index 2 (RH adjusted)' },
      { id: 'pollution_index3', label: 'Pollution Index 3 (T adjusted)' }
    ];

    function getSelectedDevices(){
      const devs = [];
      if (document.getElementById('p1').checked) devs.push('P1');
      if (document.getElementById('p2').checked) devs.push('P2');
      if (document.getElementById('p3').checked) devs.push('P3');
      if (document.getElementById('p4').checked) devs.push('P4');
      return devs;
    }

    function buildDownloadLinks(){
      const days = document.getElementById('days').value;
      const devices = getSelectedDevices();
      const container = document.getElementById('download-links');
      container.innerHTML = '';
      paramMeta.forEach(p => {
        devices.forEach(d => {
          const a = document.createElement('a');
          a.href = `/download/series?device=${d}&param=${p.id}&days=${days}`;
          a.textContent = `${p.label} (${d})`;
          a.setAttribute('download', `${d}_${p.id}.csv`);
          container.appendChild(a);
        });
      });
    }

    function computeStats(data){
      // Compute min/max per parameter across selected devices
      const stats = {};
      const devices = ['P1','P2','P3','P4'];
      paramMeta.forEach(p => {
        let values = [];
        devices.forEach(dev => {
          if (data[dev] && Array.isArray(data[dev][p.id])) {
            const arr = data[dev][p.id].filter(v => typeof v === 'number' && !Number.isNaN(v));
            values = values.concat(arr);
          }
        });
        if (values.length > 0) {
          const minVal = Math.min.apply(null, values);
          const maxVal = Math.max.apply(null, values);
          stats[p.id] = { min: minVal, max: maxVal };
        } else {
          stats[p.id] = { min: null, max: null };
        }
      });
      return stats;
    }

    function renderStatsTable(stats){
      let html = '<table><thead><tr><th>Parameter</th><th>Min</th><th>Max</th></tr></thead><tbody>';
      paramMeta.forEach(p => {
        const s = stats[p.id] || {min: null, max: null};
        const minStr = (s.min === null || Number.isNaN(s.min)) ? '-' : s.min;
        const maxStr = (s.max === null || Number.isNaN(s.max)) ? '-' : s.max;
        html += `<tr><td>${p.label}</td><td>${minStr}</td><td>${maxStr}</td></tr>`;
      });
      html += '</tbody></table>';
      html += '<caption>Computed based on selected devices and display range.</caption>';
      document.getElementById('stats-table-container').innerHTML = html;
    }

    function loadGraphs() {
      const days = document.getElementById('days').value;
      const show_p1 = document.getElementById('p1').checked;
      const show_p2 = document.getElementById('p2').checked;
      const show_p3 = document.getElementById('p3').checked;
      const show_p4 = document.getElementById('p4').checked;

      $.get(`/api/graphs?days=${days}&show_p1=${show_p1}&show_p2=${show_p2}&show_p3=${show_p3}&show_p4=${show_p4}`, function(data) {
        paramMeta.forEach(p => {
          const traces = [];
          ['P1','P2','P3','P4'].forEach(dev => {
            if (data[dev] && data[dev][p.id] && data[dev]['timestamp']) {
              traces.push({
                x: data[dev]['timestamp'],
                y: data[dev][p.id],
                name: dev,
                mode: 'lines',
                type: 'scatter'
              });
            }
          });
          const layout = {
            title: { text: p.label, font: { color: '#e6e6e6' } },
            xaxis: { title: 'Time', type: 'date', gridcolor: '#2a3242', tickfont: {color: '#cfd6e4'}, titlefont: {color: '#cfd6e4'} },
            yaxis: { title: p.label, gridcolor: '#2a3242', tickfont: {color: '#cfd6e4'}, titlefont: {color: '#cfd6e4'} },
            margin: { l: 40, r: 20, t: 40, b: 40 },
            legend: { orientation: 'h', font: { color: '#cfd6e4' } },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)'
          };
          Plotly.newPlot(p.id, traces, layout, {displayModeBar: false});
        });
        buildDownloadLinks();
        const stats = computeStats(data);
        renderStatsTable(stats);
      });
    }

    document.getElementById('reload').addEventListener('click', loadGraphs);
    document.getElementById('days').addEventListener('change', loadGraphs);
    document.getElementById('p1').addEventListener('change', loadGraphs);
    document.getElementById('p2').addEventListener('change', loadGraphs);
    document.getElementById('p3').addEventListener('change', loadGraphs);
    document.getElementById('p4').addEventListener('change', loadGraphs);

    // Initial load only (no auto-refresh)
    loadGraphs();
  </script>
</body>
</html>
"""

# --------------------------------------------------------------------------------------
# Data loading, computation & API helpers
# --------------------------------------------------------------------------------------

def parse_args():
    parser = argparse.ArgumentParser(description="DataViewer Ver4 - Browser Graphs via Python")
    parser.add_argument('--port', type=int, default=DEFAULT_PORT, help=f'Web server port (default: {DEFAULT_PORT})')
    parser.add_argument('--days', type=int, default=DEFAULT_DAYS, help=f'Initial days range (default: {DEFAULT_DAYS})')
    parser.add_argument('--p1-path', type=str, default=DEFAULT_P1_PATH, help='Path to P1 CSV')
    parser.add_argument('--p2-path', type=str, default=DEFAULT_P2_PATH, help='Path to P2 CSV')
    parser.add_argument('--p3-path', type=str, default=DEFAULT_P3_PATH, help='Path to P3 CSV')
    parser.add_argument('--p4-path', type=str, default=DEFAULT_P4_PATH, help='Path to P4 CSV')
    return parser.parse_args()


def _read_csv(csv_path: str, days: int) -> Optional[pd.DataFrame]:
    if not csv_path or not os.path.exists(csv_path):
        logger.warning(f"CSV not found: {csv_path}")
        return None
    try:
        df = pd.read_csv(csv_path)
        if 'timestamp' not in df.columns:
            logger.warning(f"Missing 'timestamp' in {csv_path}")
            return None
        # Parse timestamps (string or numeric epoch)
        try:
            if pd.api.types.is_numeric_dtype(df['timestamp']):
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s', errors='coerce')
            else:
                df['timestamp'] = pd.to_datetime(df['timestamp'].astype(str), errors='coerce')
        except Exception:
            df['timestamp'] = pd.to_datetime(df['timestamp'].astype(str), errors='coerce')
        df = df.dropna(subset=['timestamp'])
        # Coerce numeric columns
        for col in ["temperature", "humidity", "pressure", "gas_resistance", "absolute_humidity"]:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
        # Filter by days
        if days and days > 0:
            cutoff = datetime.datetime.now() - datetime.timedelta(days=days)
            df = df[df['timestamp'] >= cutoff]
        df = df.sort_values('timestamp')
        return df
    except Exception as e:
        logger.error(f"Error reading CSV {csv_path}: {e}")
        return None


def _compute_discomfort_index(df: pd.DataFrame) -> pd.Series:
    # DI = T - 0.55*(1 - RH/100)*(T - 14.5)
    if 'temperature' not in df or 'humidity' not in df:
        return pd.Series([None] * len(df))
    T = df['temperature']
    RH = df['humidity']
    try:
        di = T - 0.55 * (1 - RH/100.0) * (T - 14.5)
        return di
    except Exception:
        return pd.Series([None] * len(df))


def _compute_pollution_indices(df: pd.DataFrame, alpha: float = 0.02):
    # Base proxy: inverse of gas_resistance scaled
    if 'gas_resistance' not in df:
        base = pd.Series([None] * len(df))
    else:
        gr = pd.to_numeric(df['gas_resistance'], errors='coerce')
        # Avoid divide-by-zero
        base = 1e6 / gr.replace(0, pd.NA)
    # Humidity adjustment
    if 'humidity' in df:
        rh = pd.to_numeric(df['humidity'], errors='coerce')
        adj_rh = base * (1 + (rh - 50.0)/100.0)
    else:
        adj_rh = pd.Series([None] * len(df))
    # Temperature adjustment
    if 'temperature' in df:
        T = pd.to_numeric(df['temperature'], errors='coerce')
        adj_T = base * (math.e ** (alpha * (T - 25.0)))
    else:
        adj_T = pd.Series([None] * len(df))
    return base, adj_rh, adj_T


def build_series_with_indices(df: pd.DataFrame) -> Dict[str, Any]:
    result = {
        'timestamp': df['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S').tolist(),
        'temperature': df['temperature'].tolist() if 'temperature' in df else [],
        'humidity': df['humidity'].tolist() if 'humidity' in df else [],
        'absolute_humidity': df['absolute_humidity'].tolist() if 'absolute_humidity' in df else [],
        'pressure': df['pressure'].tolist() if 'pressure' in df else [],
        'gas_resistance': df['gas_resistance'].tolist() if 'gas_resistance' in df else [],
    }
    # Compute discomfort index
    di = _compute_discomfort_index(df)
    result['discomfort_index'] = di.tolist()
    # Compute pollution proxies
    p1, p2, p3 = _compute_pollution_indices(df)
    result['pollution_index1'] = p1.tolist()
    result['pollution_index2'] = p2.tolist()
    result['pollution_index3'] = p3.tolist()
    return result


# --------------------------------------------------------------------------------------
# App Factory
# --------------------------------------------------------------------------------------

def create_app(config: Dict[str, Any]) -> Flask:
    app = Flask(__name__)

    @app.route('/')
    def index():
        return render_template_string(INDEX_HTML)

    @app.route('/api/graphs')
    def api_graphs():
        try:
            days = request.args.get('days', default=config.get('days', DEFAULT_DAYS), type=int)
            show_p1 = request.args.get('show_p1', default='true').lower() == 'true'
            show_p2 = request.args.get('show_p2', default='true').lower() == 'true'
            show_p3 = request.args.get('show_p3', default='true').lower() == 'true'
            show_p4 = request.args.get('show_p4', default='true').lower() == 'true'

            result: Dict[str, Any] = {}
            if show_p1:
                df1 = _read_csv(config.get('p1_path'), days)
                if df1 is not None and not df1.empty:
                    result['P1'] = build_series_with_indices(df1)
            if show_p2:
                df2 = _read_csv(config.get('p2_path'), days)
                if df2 is not None and not df2.empty:
                    result['P2'] = build_series_with_indices(df2)
            if show_p3:
                df3 = _read_csv(config.get('p3_path'), days)
                if df3 is not None and not df3.empty:
                    result['P3'] = build_series_with_indices(df3)
            if show_p4:
                df4 = _read_csv(config.get('p4_path'), days)
                if df4 is not None and not df4.empty:
                    result['P4'] = build_series_with_indices(df4)

            return jsonify(result)
        except Exception as e:
            logger.error(f"/api/graphs failed: {e}")
            return jsonify({'error': str(e)}), 500

    # Download full fixed CSV endpoints (as-is)
    @app.route('/download/<device_id>')
    def download_device_csv(device_id: str):
        mapping = {
            'p1': config.get('p1_path'),
            'p2': config.get('p2_path'),
            'p3': config.get('p3_path'),
            'p4': config.get('p4_path'),
        }
        path = mapping.get(device_id.lower())
        if not path or not os.path.exists(path):
            return jsonify({'error': 'file not found'}), 404
        return send_from_directory(os.path.dirname(path), os.path.basename(path), as_attachment=True)

    # Download per-parameter series as CSV
    @app.route('/download/series')
    def download_series():
        try:
            device = request.args.get('device', default='P1').upper()
            param = request.args.get('param', default='temperature')
            days = request.args.get('days', default=config.get('days', DEFAULT_DAYS), type=int)

            path_map = {
                'P1': config.get('p1_path'),
                'P2': config.get('p2_path'),
                'P3': config.get('p3_path'),
                'P4': config.get('p4_path'),
            }
            csv_path = path_map.get(device)
            if not csv_path or not os.path.exists(csv_path):
                return jsonify({'error': f'CSV not found for {device}'}), 404

            df = _read_csv(csv_path, days)
            if df is None or df.empty:
                return jsonify({'error': 'No data in selected range'}), 404

            # Build computed columns if needed
            series_map = build_series_with_indices(df)
            if param not in series_map:
                # For original columns not in computed map, add them
                if param in df.columns:
                    series = df[param].tolist()
                else:
                    return jsonify({'error': f'Unknown parameter: {param}'}), 400
                timestamps = df['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S').tolist()
            else:
                timestamps = series_map['timestamp']
                series = series_map[param]

            # Compose CSV payload in-memory
            import io
            output = io.StringIO()
            output.write('timestamp,')
            output.write(param)
            output.write('\n')
            for t, v in zip(timestamps, series):
                # Skip NaN/None rows
                if v is None:
                    continue
                try:
                    if pd.isna(v):
                        continue
                except Exception:
                    pass
                output.write(f"{t},{v}\n")
            payload = output.getvalue()
            output.close()

            filename = f"{device}_{param}_{days}d.csv"
            return Response(payload, mimetype='text/csv', headers={"Content-Disposition": f"attachment; filename={filename}"})
        except Exception as e:
            logger.error(f"/download/series failed: {e}")
            return jsonify({'error': str(e)}), 500

    return app


# --------------------------------------------------------------------------------------
# Main
# --------------------------------------------------------------------------------------

def main():
    args = parse_args()
    config = {
        'port': args.port,
        'days': args.days,
        'p1_path': args.p1_path,
        'p2_path': args.p2_path,
        'p3_path': args.p3_path,
        'p4_path': args.p4_path,
    }

    logger.info("Starting DataViewer Ver4")
    logger.info(f"P1: {config['p1_path']}")
    logger.info(f"P2: {config['p2_path']}")
    logger.info(f"P3: {config['p3_path']}")
    logger.info(f"P4: {config['p4_path']}")

    app = create_app(config)
    # Bind strictly to AP interface per prior guidance
    app.run(host='192.168.0.2', port=config['port'], debug=False)


if __name__ == '__main__':
    main()
