#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DataViewerVer1 Ver3 - Browser-based Environmental Data Viewer (Python/Flask + Plotly)

Ver3 adds:
- Per-graph CSV download (on-the-fly export of timestamp + selected parameter)
- Discomfort Index (不快指数) computed from temperature and humidity
- Air pollution proxy models computed from gas_resistance, temperature, humidity:
  * pollution_index1 = 1e6 / gas_resistance (inverse gas resistance proxy)
  * pollution_index2 = pollution_index1 * (1 + (RH - 50)/100) (humidity-adjusted)
  * pollution_index3 = pollution_index1 * exp(alpha*(T-25)) with alpha=0.02 (temperature-adjusted)

Data source:
- Fixed CSV files generated by P1 system, per device (P1..P4, no CO2):
  /var/lib(FromThonny)/raspap_solo/data/RawData_P1/P1_fixed.csv
  /var/lib(FromThonny)/raspap_solo/data/RawData_P2/P2_fixed.csv
  /var/lib(FromThonny)/raspap_solo/data/RawData_P3/P3_fixed.csv
  /var/lib(FromThonny)/raspap_solo/data/RawData_P4/P4_fixed.csv

API:
- GET /api/graphs?days=1&show_p1=true&show_p2=true&show_p3=true&show_p4=true
  Returns time-series for temperature, humidity, absolute_humidity, pressure, gas_resistance,
  plus discomfort_index, pollution_index1, pollution_index2, pollution_index3 (if computable).

- GET /download/series?device=P2&param=discomfort_index&days=7
  Returns a CSV with columns [timestamp, param] for the selected device and parameter.

- GET /download/p1 .. /download/p4
  Returns the fixed CSV file as-is for each device.

UI:
- Client-side Plotly rendering for original parameters and the new computed indices.
- Download buttons per parameter to fetch per-parameter CSV (device selectors provided by user checks).

Dependencies:
- Flask, pandas, plotly
  pip install flask pandas plotly
"""

import os
import math
import argparse
import logging
import datetime
from typing import Optional, Dict, Any, List

import pandas as pd
from flask import Flask, jsonify, render_template_string, request, send_from_directory, Response

# --------------------------------------------------------------------------------------
# Configuration & Logging
# --------------------------------------------------------------------------------------

DEFAULT_P1_PATH = "/var/lib(FromThonny)/raspap_solo/data/RawData_P1/P1_fixed.csv"
DEFAULT_P2_PATH = "/var/lib(FromThonny)/raspap_solo/data/RawData_P2/P2_fixed.csv"
DEFAULT_P3_PATH = "/var/lib(FromThonny)/raspap_solo/data/RawData_P3/P3_fixed.csv"
DEFAULT_P4_PATH = "/var/lib(FromThonny)/raspap_solo/data/RawData_P4/P4_fixed.csv"
DEFAULT_PORT = 8081
DEFAULT_DAYS = 1
DEFAULT_REFRESH_SEC = 10

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
    ]
)
logger = logging.getLogger("DataViewerVer1_v3")

# --------------------------------------------------------------------------------------
# HTML Template (client renders Plotly graphs using /api/graphs)
# --------------------------------------------------------------------------------------

INDEX_HTML = """
<!DOCTYPE html>
<html lang=\"ja\">
<head>
  <meta charset=\"UTF-8\" />
  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />
  <title>DataViewerVer1 Ver3</title>
  <script src=\"https://cdn.plot.ly/plotly-2.27.0.min.js\"></script>
  <script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .controls { margin-bottom: 16px; }
    .graphs { display: grid; grid-template-columns: repeat(auto-fit, minmax(420px, 1fr)); gap: 16px; }
    .graph { border: 1px solid #ddd; border-radius: 6px; padding: 8px; }
    h1 { margin-top: 0; }
    label { margin-right: 12px; }
    select, input[type=checkbox] { margin-right: 8px; }
    .downloads { margin: 10px 0; font-size: 14px; }
    .downloads a { margin-right: 10px; }
  </style>
</head>
<body>
  <h1>DataViewerVer1 Ver3</h1>
  <div class=\"controls\">
    <label>表示期間(Days):
      <select id=\"days\">
        <option value=\"1\" selected>1</option>
        <option value=\"7\">7</option>
        <option value=\"30\">30</option>
      </select>
    </label>
    <label><input type=\"checkbox\" id=\"p1\" checked /> P1</label>
    <label><input type=\"checkbox\" id=\"p2\" checked /> P2</label>
    <label><input type=\"checkbox\" id=\"p3\" checked /> P3</label>
    <label><input type=\"checkbox\" id=\"p4\" checked /> P4</label>
    <button id=\"reload\">Reload</button>
    <span style=\"margin-left:12px;color:#666;\">Auto-refresh: {{ refresh_sec }}s</span>
  </div>

  <div class=\"downloads\">
    <strong>CSVダウンロード（表示期間・デバイスを反映）:</strong>
    <span id=\"download-links\"></span>\n  </div>\n\n  <div class=\"downloads\">\n    <strong>固定CSVダウンロード（全データ）:</strong>\n    <a href=\"/download/p1\" download> P1 全データ</a>\n    <a href=\"/download/p2\" download> P2 全データ</a>\n    <a href=\"/download/p3\" download> P3 全データ</a>\n    <a href=\"/download/p4\" download> P4 全データ</a>\n  </div>
  </div>

  <div class=\"graphs\">
    <div class=\"graph\"><div id=\"temperature\"></div></div>
    <div class=\"graph\"><div id=\"humidity\"></div></div>
    <div class=\"graph\"><div id=\"absolute_humidity\"></div></div>
    <div class=\"graph\"><div id=\"pressure\"></div></div>
    <div class=\"graph\"><div id=\"gas_resistance\"></div></div>
    <div class=\"graph\"><div id=\"discomfort_index\"></div></div>
    <div class=\"graph\"><div id=\"pollution_index1\"></div></div>
    <div class=\"graph\"><div id=\"pollution_index2\"></div></div>
    <div class=\"graph\"><div id=\"pollution_index3\"></div></div>
  </div>

  <script>
    const paramMeta = [
      { id: 'temperature', label: 'Temperature (°C)' },
      { id: 'humidity', label: 'Relative Humidity (%)' },
      { id: 'absolute_humidity', label: 'Absolute Humidity (g/m³)' },
      { id: 'pressure', label: 'Pressure (hPa)' },
      { id: 'gas_resistance', label: 'Gas Resistance (Ω)' },
      { id: 'discomfort_index', label: 'Discomfort Index' },
      { id: 'pollution_index1', label: 'Pollution Index 1 (1e6/GR)' },
      { id: 'pollution_index2', label: 'Pollution Index 2 (RH adjusted)' },
      { id: 'pollution_index3', label: 'Pollution Index 3 (T adjusted)' }
    ];

    function getSelectedDevices(){
      const devs = [];
      if (document.getElementById('p1').checked) devs.push('P1');
      if (document.getElementById('p2').checked) devs.push('P2');
      if (document.getElementById('p3').checked) devs.push('P3');
      if (document.getElementById('p4').checked) devs.push('P4');
      return devs;
    }

    function buildDownloadLinks(){
      const days = document.getElementById('days').value;
      const devices = getSelectedDevices();
      const container = document.getElementById('download-links');
      container.innerHTML = '';
      paramMeta.forEach(p => {
        devices.forEach(d => {
          const a = document.createElement('a');
          a.href = `/download/series?device=${d}&param=${p.id}&days=${days}`;
          a.textContent = `${p.label} (${d})`;
          a.setAttribute('download', `${d}_${p.id}.csv`);
          container.appendChild(a);
        });
      });
    }

    function loadGraphs() {
      const days = document.getElementById('days').value;
      const show_p1 = document.getElementById('p1').checked;
      const show_p2 = document.getElementById('p2').checked;
      const show_p3 = document.getElementById('p3').checked;
      const show_p4 = document.getElementById('p4').checked;

      $.get(`/api/graphs?days=${days}&show_p1=${show_p1}&show_p2=${show_p2}&show_p3=${show_p3}&show_p4=${show_p4}`, function(data) {
        paramMeta.forEach(p => {
          const traces = [];
          ['P1','P2','P3','P4'].forEach(dev => {
            if (data[dev] && data[dev][p.id] && data[dev]['timestamp']) {
              traces.push({
                x: data[dev]['timestamp'],
                y: data[dev][p.id],
                name: dev,
                mode: 'lines',
                type: 'scatter'
              });
            }
          });
          Plotly.newPlot(p.id, traces, {
            title: p.label,
            xaxis: { title: 'Time', type: 'date' },
            yaxis: { title: p.label },
            margin: { l: 40, r: 20, t: 40, b: 40 },
            legend: { orientation: 'h' }
          });
        });
        buildDownloadLinks();
      });
    }

    document.getElementById('reload').addEventListener('click', loadGraphs);
    document.getElementById('days').addEventListener('change', loadGraphs);
    document.getElementById('p1').addEventListener('change', loadGraphs);
    document.getElementById('p2').addEventListener('change', loadGraphs);
    document.getElementById('p3').addEventListener('change', loadGraphs);
    document.getElementById('p4').addEventListener('change', loadGraphs);

    // Initial load and periodic refresh
    loadGraphs();
    setInterval(loadGraphs, {{ refresh_sec }} * 1000);
  </script>
</body>
</html>
"""

# --------------------------------------------------------------------------------------
# Data loading, computation & API helpers
# --------------------------------------------------------------------------------------

def parse_args():
    parser = argparse.ArgumentParser(description="DataViewerVer1 Ver3 - Browser Graphs via Python")
    parser.add_argument('--port', type=int, default=DEFAULT_PORT, help=f'Web server port (default: {DEFAULT_PORT})')
    parser.add_argument('--days', type=int, default=DEFAULT_DAYS, help=f'Initial days range (default: {DEFAULT_DAYS})')
    parser.add_argument('--p1-path', type=str, default=DEFAULT_P1_PATH, help='Path to P1 CSV')
    parser.add_argument('--p2-path', type=str, default=DEFAULT_P2_PATH, help='Path to P2 CSV')
    parser.add_argument('--p3-path', type=str, default=DEFAULT_P3_PATH, help='Path to P3 CSV')
    parser.add_argument('--p4-path', type=str, default=DEFAULT_P4_PATH, help='Path to P4 CSV')
    parser.add_argument('--refresh', type=int, default=DEFAULT_REFRESH_SEC, help=f'Auto refresh seconds (default: {DEFAULT_REFRESH_SEC})')
    return parser.parse_args()


def _read_csv(csv_path: str, days: int) -> Optional[pd.DataFrame]:
    if not csv_path or not os.path.exists(csv_path):
        logger.warning(f"CSV not found: {csv_path}")
        return None
    try:
        df = pd.read_csv(csv_path)
        if 'timestamp' not in df.columns:
            logger.warning(f"Missing 'timestamp' in {csv_path}")
            return None
        # Parse timestamps (string or numeric epoch)
        try:
            if pd.api.types.is_numeric_dtype(df['timestamp']):
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s', errors='coerce')
            else:
                df['timestamp'] = pd.to_datetime(df['timestamp'].astype(str), errors='coerce')
        except Exception:
            df['timestamp'] = pd.to_datetime(df['timestamp'].astype(str), errors='coerce')
        df = df.dropna(subset=['timestamp'])
        # Coerce numeric columns
        for col in ["temperature", "humidity", "pressure", "gas_resistance", "absolute_humidity"]:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
        # Filter by days
        if days and days > 0:
            cutoff = datetime.datetime.now() - datetime.timedelta(days=days)
            df = df[df['timestamp'] >= cutoff]
        df = df.sort_values('timestamp')
        return df
    except Exception as e:
        logger.error(f"Error reading CSV {csv_path}: {e}")
        return None


def _compute_discomfort_index(df: pd.DataFrame) -> pd.Series:
    # DI = T - 0.55*(1 - RH/100)*(T - 14.5)
    if 'temperature' not in df or 'humidity' not in df:
        return pd.Series([None] * len(df))
    T = df['temperature']
    RH = df['humidity']
    try:
        di = T - 0.55 * (1 - RH/100.0) * (T - 14.5)
        return di
    except Exception:
        return pd.Series([None] * len(df))


def _compute_pollution_indices(df: pd.DataFrame, alpha: float = 0.02):
    # Base proxy: inverse of gas_resistance scaled
    if 'gas_resistance' not in df:
        base = pd.Series([None] * len(df))
    else:
        gr = pd.to_numeric(df['gas_resistance'], errors='coerce')
        # Avoid divide-by-zero
        base = 1e6 / gr.replace(0, pd.NA)
    # Humidity adjustment
    if 'humidity' in df:
        rh = pd.to_numeric(df['humidity'], errors='coerce')
        adj_rh = base * (1 + (rh - 50.0)/100.0)
    else:
        adj_rh = pd.Series([None] * len(df))
    # Temperature adjustment
    if 'temperature' in df:
        T = pd.to_numeric(df['temperature'], errors='coerce')
        adj_T = base * (math.e ** (alpha * (T - 25.0)))
    else:
        adj_T = pd.Series([None] * len(df))
    return base, adj_rh, adj_T


def build_series_with_indices(df: pd.DataFrame) -> Dict[str, Any]:
    result = {
        'timestamp': df['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S').tolist(),
        'temperature': df['temperature'].tolist() if 'temperature' in df else [],
        'humidity': df['humidity'].tolist() if 'humidity' in df else [],
        'absolute_humidity': df['absolute_humidity'].tolist() if 'absolute_humidity' in df else [],
        'pressure': df['pressure'].tolist() if 'pressure' in df else [],
        'gas_resistance': df['gas_resistance'].tolist() if 'gas_resistance' in df else [],
    }
    # Compute discomfort index
    di = _compute_discomfort_index(df)
    result['discomfort_index'] = di.tolist()
    # Compute pollution proxies
    p1, p2, p3 = _compute_pollution_indices(df)
    result['pollution_index1'] = p1.tolist()
    result['pollution_index2'] = p2.tolist()
    result['pollution_index3'] = p3.tolist()
    return result


# --------------------------------------------------------------------------------------
# App Factory
# --------------------------------------------------------------------------------------

def create_app(config: Dict[str, Any]) -> Flask:
    app = Flask(__name__)

    @app.route('/')
    def index():
        return render_template_string(INDEX_HTML, refresh_sec=config.get('refresh', DEFAULT_REFRESH_SEC))

    @app.route('/api/graphs')
    def api_graphs():
        try:
            days = request.args.get('days', default=config.get('days', DEFAULT_DAYS), type=int)
            show_p1 = request.args.get('show_p1', default='true').lower() == 'true'
            show_p2 = request.args.get('show_p2', default='true').lower() == 'true'
            show_p3 = request.args.get('show_p3', default='true').lower() == 'true'
            show_p4 = request.args.get('show_p4', default='true').lower() == 'true'

            result: Dict[str, Any] = {}
            if show_p1:
                df1 = _read_csv(config.get('p1_path'), days)
                if df1 is not None and not df1.empty:
                    result['P1'] = build_series_with_indices(df1)
            if show_p2:
                df2 = _read_csv(config.get('p2_path'), days)
                if df2 is not None and not df2.empty:
                    result['P2'] = build_series_with_indices(df2)
            if show_p3:
                df3 = _read_csv(config.get('p3_path'), days)
                if df3 is not None and not df3.empty:
                    result['P3'] = build_series_with_indices(df3)
            if show_p4:
                df4 = _read_csv(config.get('p4_path'), days)
                if df4 is not None and not df4.empty:
                    result['P4'] = build_series_with_indices(df4)

            return jsonify(result)
        except Exception as e:
            logger.error(f"/api/graphs failed: {e}")
            return jsonify({'error': str(e)}), 500

    # Download full fixed CSV endpoints (as-is)
    @app.route('/download/<device_id>')
    def download_device_csv(device_id: str):
        mapping = {
            'p1': config.get('p1_path'),
            'p2': config.get('p2_path'),
            'p3': config.get('p3_path'),
            'p4': config.get('p4_path'),
        }
        path = mapping.get(device_id.lower())
        if not path or not os.path.exists(path):
            return jsonify({'error': 'file not found'}), 404
        return send_from_directory(os.path.dirname(path), os.path.basename(path), as_attachment=True)

    # Download per-parameter series as CSV
    @app.route('/download/series')
    def download_series():
        try:
            device = request.args.get('device', default='P1').upper()
            param = request.args.get('param', default='temperature')
            days = request.args.get('days', default=config.get('days', DEFAULT_DAYS), type=int)

            path_map = {
                'P1': config.get('p1_path'),
                'P2': config.get('p2_path'),
                'P3': config.get('p3_path'),
                'P4': config.get('p4_path'),
            }
            csv_path = path_map.get(device)
            if not csv_path or not os.path.exists(csv_path):
                return jsonify({'error': f'CSV not found for {device}'}), 404

            df = _read_csv(csv_path, days)
            if df is None or df.empty:
                return jsonify({'error': 'No data in selected range'}), 404

            # Build computed columns if needed
            series_map = build_series_with_indices(df)
            if param not in series_map:
                # For original columns not in computed map, add them
                if param in df.columns:
                    series = df[param].tolist()
                else:
                    return jsonify({'error': f'Unknown parameter: {param}'}), 400
                timestamps = df['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S').tolist()
            else:
                timestamps = series_map['timestamp']
                series = series_map[param]

            # Compose CSV payload in-memory
            import io
            output = io.StringIO()
            output.write('timestamp,')
            output.write(param)
            output.write('\n')
            for t, v in zip(timestamps, series):
                # Skip NaN/None rows
                if v is None:
                    continue
                try:
                    if pd.isna(v):
                        continue
                except Exception:
                    pass
                output.write(f"{t},{v}\n")
            payload = output.getvalue()
            output.close()

            filename = f"{device}_{param}_{days}d.csv"
            return Response(payload, mimetype='text/csv', headers={"Content-Disposition": f"attachment; filename={filename}"})
        except Exception as e:
            logger.error(f"/download/series failed: {e}")
            return jsonify({'error': str(e)}), 500

    return app


# --------------------------------------------------------------------------------------
# Main
# --------------------------------------------------------------------------------------

def main():
    args = parse_args()
    config = {
        'port': args.port,
        'days': args.days,
        'refresh': args.refresh,
        'p1_path': args.p1_path,
        'p2_path': args.p2_path,
        'p3_path': args.p3_path,
        'p4_path': args.p4_path,
    }

    logger.info("Starting DataViewerVer1 Ver3")
    logger.info(f"P1: {config['p1_path']}")
    logger.info(f"P2: {config['p2_path']}")
    logger.info(f"P3: {config['p3_path']}")
    logger.info(f"P4: {config['p4_path']}")

    app = create_app(config)
    # Bind strictly to AP interface per prior guidance
    app.run(host='192.168.0.2', port=config['port'], debug=False)


if __name__ == '__main__':
    main()
