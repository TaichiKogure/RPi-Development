#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SCD41 Graph Viewer for Raspberry Pi 5
Version: 1.0.0

This module provides a simple visualization tool for SCD41 sensor data
stored in CSV format by the scd41_data_collector.py script.

Features:
- Reads CSV files generated by scd41_data_collector.py
- Displays time series graphs of CO2, temperature, humidity, and absolute humidity
- Supports zooming, panning, and saving graphs
- Auto-refreshes to show the latest data

Usage:
    python3 scd41_graph_viewer.py [--data-dir DIR] [--days DAYS] [--refresh-interval SECONDS]
"""

import os
import sys
import argparse
import logging
import time
import datetime
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.animation import FuncAnimation
from matplotlib.widgets import Button

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("scd41_graph_viewer.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class SCD41GraphViewer:
    """Class to visualize SCD41 sensor data."""
    
    def __init__(self, config=None):
        """Initialize the graph viewer with the given configuration."""
        self.config = config or {
            "data_dir": "data",
            "days": 1,
            "device_id": "SCD41",
            "refresh_interval": 60  # seconds
        }
        
        # Initialize figure and subplots
        self.fig = plt.figure(figsize=(12, 8))
        self.fig.canvas.manager.set_window_title(f"SCD41 Sensor Data Viewer - {self.config['device_id']}")
        
        # Create subplots
        self.ax1 = plt.subplot(2, 2, 1)  # CO2
        self.ax2 = plt.subplot(2, 2, 2)  # Temperature
        self.ax3 = plt.subplot(2, 2, 3)  # Humidity
        self.ax4 = plt.subplot(2, 2, 4)  # Absolute Humidity
        
        # Initialize lines
        self.line1, = self.ax1.plot([], [], 'r-', label='CO2')
        self.line2, = self.ax2.plot([], [], 'b-', label='Temperature')
        self.line3, = self.ax3.plot([], [], 'g-', label='Humidity')
        self.line4, = self.ax4.plot([], [], 'm-', label='Absolute Humidity')
        
        # Set up axes
        self.ax1.set_title('CO2 Concentration')
        self.ax1.set_xlabel('Time')
        self.ax1.set_ylabel('CO2 (ppm)')
        self.ax1.grid(True)
        
        self.ax2.set_title('Temperature')
        self.ax2.set_xlabel('Time')
        self.ax2.set_ylabel('Temperature (°C)')
        self.ax2.grid(True)
        
        self.ax3.set_title('Relative Humidity')
        self.ax3.set_xlabel('Time')
        self.ax3.set_ylabel('Humidity (%)')
        self.ax3.grid(True)
        
        self.ax4.set_title('Absolute Humidity')
        self.ax4.set_xlabel('Time')
        self.ax4.set_ylabel('Absolute Humidity (g/m³)')
        self.ax4.grid(True)
        
        # Add buttons for time range selection
        self.fig.subplots_adjust(bottom=0.15)
        
        self.btn_1d_ax = plt.axes([0.2, 0.05, 0.1, 0.05])
        self.btn_3d_ax = plt.axes([0.35, 0.05, 0.1, 0.05])
        self.btn_7d_ax = plt.axes([0.5, 0.05, 0.1, 0.05])
        self.btn_30d_ax = plt.axes([0.65, 0.05, 0.1, 0.05])
        
        self.btn_1d = Button(self.btn_1d_ax, '1 Day')
        self.btn_3d = Button(self.btn_3d_ax, '3 Days')
        self.btn_7d = Button(self.btn_7d_ax, '7 Days')
        self.btn_30d = Button(self.btn_30d_ax, '30 Days')
        
        self.btn_1d.on_clicked(lambda event: self.set_days(1))
        self.btn_3d.on_clicked(lambda event: self.set_days(3))
        self.btn_7d.on_clicked(lambda event: self.set_days(7))
        self.btn_30d.on_clicked(lambda event: self.set_days(30))
        
        # Add timestamp for last update
        self.timestamp_text = self.fig.text(0.01, 0.01, '', fontsize=8)
        
        # Adjust layout
        self.fig.tight_layout(rect=[0, 0.1, 1, 0.95])
        
        # Initialize animation
        self.ani = FuncAnimation(
            self.fig, 
            self.update, 
            interval=self.config["refresh_interval"] * 1000,
            cache_frame_data=False
        )
    
    def set_days(self, days):
        """Set the number of days to display."""
        self.config["days"] = days
        logger.info(f"Setting display range to {days} days")
        self.update(None)
    
    def load_data(self):
        """Load data from CSV files."""
        end_date = datetime.datetime.now().date()
        start_date = end_date - datetime.timedelta(days=self.config["days"])
        
        # Generate list of dates to check
        date_list = []
        current_date = start_date
        while current_date <= end_date:
            date_list.append(current_date.strftime("%Y-%m-%d"))
            current_date += datetime.timedelta(days=1)
        
        # Load data from each date's CSV file
        frames = []
        for date_str in date_list:
            csv_path = os.path.join(
                self.config["data_dir"], 
                f"{self.config['device_id']}_{date_str}.csv"
            )
            
            if os.path.exists(csv_path):
                try:
                    df = pd.read_csv(csv_path)
                    frames.append(df)
                    logger.info(f"Loaded data from {csv_path}")
                except Exception as e:
                    logger.error(f"Error loading data from {csv_path}: {e}")
        
        if not frames:
            logger.warning("No data files found")
            return None
        
        # Combine all data frames
        data = pd.concat(frames, ignore_index=True)
        
        # Convert timestamp to datetime
        data['timestamp'] = pd.to_datetime(data['timestamp'])
        
        # Sort by timestamp
        data = data.sort_values('timestamp')
        
        # Filter by date range
        start_datetime = datetime.datetime.combine(start_date, datetime.time.min)
        data = data[data['timestamp'] >= start_datetime]
        
        return data
    
    def update(self, frame):
        """Update the graph with the latest data."""
        try:
            # Load data
            data = self.load_data()
            
            if data is None or data.empty:
                logger.warning("No data available for plotting")
                return
            
            # Update lines
            self.line1.set_data(data['timestamp'], data['co2'])
            self.line2.set_data(data['timestamp'], data['temperature'])
            self.line3.set_data(data['timestamp'], data['humidity'])
            self.line4.set_data(data['timestamp'], data['absolute_humidity'])
            
            # Update axes limits
            self.ax1.set_xlim(data['timestamp'].min(), data['timestamp'].max())
            self.ax2.set_xlim(data['timestamp'].min(), data['timestamp'].max())
            self.ax3.set_xlim(data['timestamp'].min(), data['timestamp'].max())
            self.ax4.set_xlim(data['timestamp'].min(), data['timestamp'].max())
            
            # Set y-axis limits with some padding
            if not data['co2'].empty:
                co2_min = data['co2'].min()
                co2_max = data['co2'].max()
                padding = (co2_max - co2_min) * 0.1
                self.ax1.set_ylim(max(0, co2_min - padding), co2_max + padding)
            
            if not data['temperature'].empty:
                temp_min = data['temperature'].min()
                temp_max = data['temperature'].max()
                padding = (temp_max - temp_min) * 0.1
                self.ax2.set_ylim(temp_min - padding, temp_max + padding)
            
            if not data['humidity'].empty:
                hum_min = data['humidity'].min()
                hum_max = data['humidity'].max()
                padding = (hum_max - hum_min) * 0.1
                self.ax3.set_ylim(max(0, hum_min - padding), min(100, hum_max + padding))
            
            if not data['absolute_humidity'].empty:
                abs_hum_min = data['absolute_humidity'].min()
                abs_hum_max = data['absolute_humidity'].max()
                padding = (abs_hum_max - abs_hum_min) * 0.1
                self.ax4.set_ylim(max(0, abs_hum_min - padding), abs_hum_max + padding)
            
            # Format x-axis dates
            for ax in [self.ax1, self.ax2, self.ax3, self.ax4]:
                ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M'))
                ax.tick_params(axis='x', rotation=45)
            
            # Update timestamp
            self.timestamp_text.set_text(f'Last updated: {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}')
            
            # Redraw
            self.fig.canvas.draw_idle()
            
            logger.info("Graph updated")
        except Exception as e:
            logger.error(f"Error updating graph: {e}")
    
    def show(self):
        """Show the graph viewer."""
        plt.show()

def main():
    """Main function to run the graph viewer."""
    parser = argparse.ArgumentParser(description='SCD41 Graph Viewer')
    parser.add_argument('--data-dir', type=str, default='data', help='Directory containing data files')
    parser.add_argument('--days', type=int, default=1, help='Number of days to display')
    parser.add_argument('--device-id', type=str, default='SCD41', help='Device ID for CSV data')
    parser.add_argument('--refresh-interval', type=int, default=60, help='Refresh interval in seconds')
    args = parser.parse_args()
    
    # Create configuration
    config = {
        "data_dir": args.data_dir,
        "days": args.days,
        "device_id": args.device_id,
        "refresh_interval": args.refresh_interval
    }
    
    # Create and show the graph viewer
    viewer = SCD41GraphViewer(config)
    viewer.show()

if __name__ == "__main__":
    main()